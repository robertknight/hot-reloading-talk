<!DOCTYPE html>
<html>
  <head>
    <title>Hot Reloading with React and Redux</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <link rel="stylesheet" href="theme.css">
  </head>
  <body>
    <textarea id="source">

class: center, middle

# Hot Reloading

github.com/robertknight/hot-reloading-talk

.hint[Press 'P' for slide notes]

---

class: middle

## Rob Knight

@robknight_

github.com/robertknight

Developer at [Hypothesis](https://hypothes.is)

???
- I'm a developer at Hypothesis. We make open source tools for annotating the web.
- My experience is mostly with React but I'm interested in how the ideas
  can be useful for other frameworks, or no framework at all.

---

class: middle

.center[![XKCD Compiling](https://imgs.xkcd.com/comics/compiling.png)]

???

(Shorten the below, the audience knows this)

- Building user interfaces is all about tweaking things, being able to make
  changes and see the effects quickly.
- With static content and simple web apps this is easy:
  Make a change, then press a key to reload the page.

---

class: middle

## LiveReload with Ember CLI

- Run `ember serve`
- Edit styles → Styles reloads automatically
- Edit JavaScript → Page reloads automatically.

???
- Out of the box, Ember CLI goes a step further and takes care of
  reloading your app automatically when styles or code changes.

---

class: middle

## LiveReload with Ember CLI

- Run `ember serve`
- Edit styles → Styles reloads automatically
- *Edit JavaScript → Page reloads automatically* → **Loses state**

???
- There is a limitation with this part though, any state
  that hasn't been persisted to the server, to local storage
  or in the URL is lost.
- Can we do better? Can we make it possible to edit code and
  not lose state.

---

class: middle

> **hot reloading**
>
> */hɒt/ /riːˈləʊd/*
>
> *n* Feature that lets you change _code_ in your app
> and see the changes immediately without losing state.

???
- Time for a demo

---

class: middle, center

# Demo

???
- Demo app is a simple dashboard that lets you compare commit
  activity from different GitHub projects over the past year.
- { Brief demo of functionality: Add chart, remove chart, zoom in }
- { Point out that we have multiple charts, so not trivial to put state into URL }
- { Hot reload demo: Increase height of zoomed-in chart }
- { Hot reload demo: Tweak chart style }
- { Hot reload demo: Tweak loading screen. This is where Redux comes in. }

---

# Outline

1. Hot reloading JavaScript modules
1. Replacing components at runtime
1. Preserving state
1. Hot reloading and Ember

???
- I've covered what hot reloading is and why it is useful.
- Now I'll explain the basics of how it works.
  - Getting updated code from editor to browser
  - Replacing existing UI components with new versions
  - Preserving the state of your app when loading new versions
    of components.
- I'm going to explain how this works with Webpack, React and Redux and
  then I'll talk about applying this to Ember

---

# Ingredients for Hot Reloading

1. Delivering code updates to the browser

???
- The first is step is to get a code change from a file on disk into the browser,
  and give the existing code on the page a way to make use of
  that new code.

--

1. Updating components

???
- If there are any outputs of the old code active on the page, they need
  to be updated to reflect the new code.
- The most obvious kind of output on the page are DOM elements created
  by components.
- We need to replace those elements to reflect the visual appearance and
  behavior of the new version of a component.

--

1. Preserving state

???
- When we replace components, we want to preserve the state of the
  app as far as possible.
---

## Hot Module Replacement
- System for delivering code updates to the browser
- Bundler (Webpack, Browserify, JSPM, ...)
- Client runtime

???
* In Webpack, Hot Module Replacement is a system for delivering updated versions of individual modules to the page.
* There are two parts to it, one is the module bundler and the other
  is a small client runtime.

---

.full-slide-img[![Module Tree](images/module-tree.svg)]

???
- App is divided into modules which depend on each other.
  One of the modules is the entry point, forming a dependency graph.

---

.full-slide-img[![Module Tree](images/module-tree-numbers.svg)]

???
- When you edit a file on disk, Webpack generates an incremental update
  containing only the code for the module which changed.
- It notifies the client about the change using a WebSocket message.
- The client runtime then fetches the updated code
- The logic for _applying_ the changes is app specific, so your modules
  provide the code for that.

---

class: middle

- Client knows about dependency graph
- Modules register which dependencies they can process updates for
  using **module.hot** API

```js
// Register a callback for when a new version of 'Button'
// is available
module.hot.accept('./components/Button', () => {
  // 1. Load new version of component
  var NewFileList = require('./components/Button');

  // 2. ???

  // 3. Profit!
});
```

---

# Updating Views

???
- In order to load a new version of a UI component into a web app,
  we need to remove, update or replace all of the DOM elements in
  the app that were created by the changed component.

---

class:middle

```hbs
<button {{action "onClick"}}>{{label}}</button>
```

???
- In Ember, a very simple Button component might look like this

---
class:middle

```js
function Button(props) {
  return <button onClick={props.onClick}>{props.label}</button>;
}
```

???
- In React, it would look like this
- A key thing to note, is that it is just a function. This function returns
  an object describing what the DOM structure of a component looks like.
- To load a new version of Button, we just need to make the code that calls this
  function, call a new version instead.
- The new version will then return a _different_ description of what DOM elements
  and attributes should be present in the page for a button.
- The React engine then takes care of transforming whatever is currently there
  into a version that matches the new description.

---

# Updating views

app.js:
```js
var Button = require('./Button');
ReactDOM.render(<Button label="Click Me"/>, document.getElementById('root'));

*module.hot.accept('./Button', function () {
  Button = require('./Button');
  ReactDOM.render(<Button label="Click Me"/>, document.getElementById('root'));
});
```

Output:
```html
<div id="root">
  <button>Click Me</button>
</div>
```

???
- This is the "hot reloading" Hello World with React
- This works for simple components, but what if those
  components have state?

---

class: middle

- How do we preserve the state of components?
- What if we want to make changes to services as well as views?

???

---

class: middle

## Redux

- Small library for managing state in JavaScript applications
- Increasingly the standard solution in the React ecosystem

???
- The standard solution to this problem in the React ecosystem
  is the Redux library
- Redux is a small framework-independent library for managing
  how app state is stored and modified
- It is based on 3 ideas which combined together support hot reloading

---

class: middle

- As much a design pattern as a library
- Inspired by _Elm_, a functional compile-to-JavaScript language.
- Components in Elm are stateless, just a collection of 3 functions

???
- It is as much a design pattern as a library

---

class: middle

.large-slide-img[![Elm Component](images/elm-component.svg)]

???
- Redux is inspired by Elm and in particular a way of structuring a UI
  referred to as the 'Elm architecture'.
- A UI component in Elm consists of 3 pure functions: One to get the
  initial state for the component, one that takes the state and
  returns a description of the UI to render given that state and finally 
  one to get the new state given the current state and an action.
- A template is equivalent to a view function
- An 'action' is something like a mouse click, or a WebSocket message
- Important to notice for hot reloading: Component is entirely pure. Contains
  the logic to manage the state but doesn't store it. Therefore, to do
  a hot reload, we just need to change the arrows on the left to point
  to the new version.

---

.large-slide-img[![Elm Component](images/elm-component-reload-1.svg)]

???
- Since the component is pure, in order to replace it with a new version
  at runtime, all we need to do is redirect the input arrows that feed
  state updates and the action signal into it to point to the new
  version

---

.large-slide-img[![Elm Component](images/elm-component-reload-2.svg)]

---

class: middle

.large-slide-img[![React/Redux Component](images/react-redux-component.svg)]

???
- By constrast, this is the architecture of React/Redux
- The data flow is the same. The main difference is that
  whereas in Elm the three functions are part of the same component,
  here the view part is React, the update/init parts are merged together
  into a single 'reducer' function in Redux
- The view and reducer components are still pure, so hot reloading works
  the same way

---

# Three Basic Principles

1 - Store all of your application's state in a single, immutable object.

```js
{
  charts: [{
    repository: 'facebook/react',
    isLoading: false,
    data: [...],
  },
    ...
  ],
  focusedChart: 0,
}
```

_Better yet: Make it a **plain JavaScript object**_

???
- The first principle is that the state of your app is stored in a single,
  immutable object, separate from the logic that updates it.
- This enables a lot of useful debug tools on its own. For example,
  you can easily expose the store as a property on the 'window' object
  for easy inspection in dev tools.
{Show state in demo app}
- Why immutable? That enforces that there is only one way to update it.

---

2 - The only way to change the state is by calling a `dispatch()` function
    with an 'action', which is just a plain JavaScript object describing
    what happened.

   ```js
   function setRepository(name) {
     return {
       type: 'SET_REPOSITORY',
       repository: name,
     };
   }

   // in the 'onSubmit' handler for the form where the user
   // chooses a repository to view
   store.dispatch(setRepository(name));
   ```

---

3 - State updates are made by a collection of functions (called 'reducers'),
    which take the current state, the action and return the new state.

```js
var initialState = {
  repository: undefined,
};

function chart(state, action) {
  switch (action.type) {
    case 'SET_REPOSITORY':
      return Object.assign({}, state, {
        repository: action.repository,
      });
    default:
      return state || initialState;
  }
}
```

???
- State updates happen by calling a function on the store, `dispatch()`
  and passing it an object describing what happened.
- In our example app, we have actions for the user selecting a repository,
  data being fetched from the GitHub API and the user zooming into or out
  of a chart.
  {Show actions in debug tools}

---

# The Redux API

```js
createStore(reducer, initialState);

store: {
  dispatch: function(action) {
    // call reducer(getState(), action) and replace
    // the state with the result
  },

  subscribe: function(listener) {
    // add a listener which will be called whenever the
    // state changes
  },

  getState: function() {
    // returns the current state of the application
  },

  replaceReducer: function (reducer) {
    // replace the 'reducer' function, this enables
    // live code updates
  }
}
```

???
- The basic API of a store is extremely simple. Call `createStore()` and
  get back an object with functions to get the current state of the app,
  list for state changes, and dispatch actions to trigger state changes.
---

# Poor man's hot reloading

- Persist state to `window.localStorage` or `window.hash`
- Restore on load

```js
var initialState = JSON.parse(atob(window.location.hash.slice(1)) || 'null');
var store = redux.createStore(rootReducer, initialState);

store.subscribe(function () {
  window.location.hash = JSON.stringify(btoa(store.getState()));
});
```

???
- By storing all our app state in a single object, we can already implement
  a simple hot reloading hack.
- Every time the app state changes, we'll serialize it and put it in
  `window.hash`
- If we reload the app, we'll deserialize that state.
{Let's go and try it out!}

---

# Hot Reloading with Redux

```js
var reducer = require('./rootReducer');

if (module.hot) {
  module.hot.accept('./rootReducer', function () {
    reducer = require('./rootReducer');
    store.replaceReducer(reducer);
  });
}
```

???
- Redux provides a `replaceReducer()` API which lets you replace the reducer
  function.
- If you have the dev tools enabled, all of the actions will be replayed,
  allowing you to see the effects of reducer changes live.
- { Demo fixing bug when resetting repo whilst zoomed in }

---

# Hot Reloading with Ember?

???
- How can we make use of this in Ember?

---

class: middle center

![Ember Redux](images/ember-redux-site.png)
ember-redux.com

???
- ember-redux is a small library which integrates Redux with Ember
- Provides convenience functions for creating a Redux store and hooking
  it up to an Ember component

---

```js
import Ember from 'ember';
import hbs from 'htmlbars-inline-precompile';
import connect from 'ember-redux/components/connect';

var stateToComputed = (state) => {
  return {
    number: state.number
  };
};

var dispatchToActions = (dispatch) => {
  return {
    add: () => dispatch({type: 'ADD'})
  };
};

var NumbersComponent = Ember.Component.extend({
    layout: hbs`
      {{number}}
      <button onclick={{action "add"}}>add</button>
    `
});

export default connect(stateToComputed, dispatchToActions)(NumbersComponent);

```
(Code from ember-redux.com Quick Start example)

---

# Summary

- Hot reloading is great for productivity
- Needs the right app architecture to be robust
- Redux is one solution. Can be integrated with Ember.

---

class: middle

github.com/robertknight/hot-reloading-talk

Rob Knight

@robknight_

???

    </textarea>
    <script src="scripts/remark.min.js">
    </script>
    <script>
      var slideshow = remark.create({
        highlightStyle: 'zenburn',
        highlightLines: true,
        ratio: '4:3',
      });
    </script>
  </body>
</html>
